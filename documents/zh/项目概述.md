# 项目概述 - CS6290 小组项目：Polymarket 信号分析

**日期**：2026-02-13

**状态**：**初版** 

## 1. 项目概述 (Project Overview)

### 核心选题

Polymarket Signal Analysis — Empirical Detection of Unusual Odds Movements.

### 核心形态

一个基于 Web 的**静态分析展示页 (Static Analytical Showcase)**。 项目组将在后台离线运行数据管道，生成特定市场的"异常事件"数据集。最终交付物是一个无需后端实时支持的网页，用于交互式地展示检测结果和统计佐证。

## 2. 目标与非目标 (Goals & Non-Goals)

### 2.1 目标 (Goals)

- **核心目标**：实现一套离线算法流程，能够输入历史数据，输出"异常事件"列表。
- **展示目标**：构建一个前端界面，清晰地将"赔率异常"与"统计佐证"（如 Z-Score 突变、成交量激增）对应展示。
- **工程目标**：
  - 实现数据清洗与重采样（Resampling）机制。
  - 实现两类特定的异常检测算法：**抢跑/内幕交易模式** 与 **平价公式破裂/套利模式**。

### 2.2 非目标 (Non-Goals)

- **不做实时**：演示时不连接 Polymarket 实时 API，不进行实时监控。
- **不做交易**：不提供买卖建议，不连接钱包。
- **不做逐笔分析**：不处理 Tick-level（逐笔）交易数据，不追踪具体账户（Whale Tracking），仅关注聚合后的价格与成交量。
- **不做复杂归因**：不尝试解释"为什么"发生异常（如不抓取外部新闻），只展示"发生了什么"。

## 3. 核心项目流程 (Project Pipeline & User Flows)

本项目的数据流向被严格划分为三个阶段：

### 阶段一：数据获取与预处理 (Data Acquisition & Preprocessing)

*目标：构建标准化的、时间对齐的历史数据集。*

1. **Ingest (获取)**:
   - 脚本调用 Polymarket API (CLOB/History) 拉取指定市场（如 "US Election 2024"）过去 6 个月的原始 OHLCV 数据。
   - 获取互斥合约对的数据（例如同时获取 "Yes" 和 "No" 的价格序列）。
2. **Clean & Align (清洗与对齐)**:
   - **填补缺失值**: 处理 API 返回的空洞。
   - **时间对齐 (Time Alignment)**: 这一点至关重要。必须确保 "Yes" 和 "No" 的价格数据在相同的时间戳上对齐（Resampling 到统一的分钟/小时级），以便后续计算平价公式。

### 阶段二：算法检测 (Algorithmic Detection)

*目标：运行离线算法，输出异常事件列表。我们将重点检测两类模式：*

1. **模式 A：重大新闻前的"抢跑"波动 (Front-running / Insider Pattern)**
   - **定义**: 在市场平静期突然出现的剧烈波动，往往预示着内幕消息泄露。
   - **检测逻辑**:
     - 计算价格的移动平均线 (MA) 和标准差 (StdDev)。
     - 识别 **Volume Spikes** (成交量激增) 伴随 **High Z-Score** (价格偏离均值 > 3σ) 的时间窗口。
   - **输出**: 标记为 "Type A: Volatility Anomaly"。
2. **模式 B：平价公式破裂与套利 (Parity Breakage / Arbitrage)**
   - **定义**: 在二元预测市场中，理论上 `Price(Yes) + Price(No)` 应等于 1。当和值显著偏离 1 时，意味着市场失效或存在无风险套利机会。
   - **检测逻辑**:
     - 计算 `Spread = |Price(Yes) + Price(No) - 1|`。
     - 当 `Spread > Threshold` (例如 0.02) 且持续时间超过 N 分钟时，视为异常。
   - **输出**: 标记为 "Type B: Arbitrage Opportunity"。

### 阶段三：结果展示 (Result Showcase)

*目标：用户在 Web 界面查看阶段二生成的分析结果。*

1. **全局概览 (Overview)**:
   - 用户打开网页，看到全量时间轴的赔率走势。
   - 时间轴上用不同颜色标记了 **Type A (波动)** 和 **Type B (套利)** 异常点。
2. **交互下钻 (Interactive Drill-down)**:
   - 用户点击一个 **Type A** 标记 -> 弹窗展示该时刻的成交量柱状图和波动率曲线（证明有人抢跑）。
   - 用户点击一个 **Type B** 标记 -> 弹窗展示 `Price(Yes) + Price(No)` 的叠加曲线（证明两线分离，和值不为1）。

## 4. 关键决策与风险管理 (Key Decisions & Risks)

### 4.1 已识别的风险 (Risks) & 缓解策略 (Mitigation)

| 风险点                             | 描述                                                         | 缓解策略 (Mitigation)                                        |
| ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **数据对齐误差 (Alignment Error)** | 如果 Yes 和 No 的交易不是发生在完全相同的毫秒，简单相加可能导致虚假的"套利信号"。 | **重采样缓冲**。在预处理阶段，将数据降频（例如 1分钟或 5分钟窗口），取该窗口内的加权平均价，以消除微观时间差带来的噪音。 |
| **浏览器性能瓶颈**                 | 6个月的高频数据直接加载会让浏览器崩溃。                      | **按需加载**。前端默认只加载"小时级"概览数据；只有用户点击特定事件时，才加载该片段的"分钟级"详情。 |
| **算法"事后诸葛亮"**               | 预计算结果可能看起来像是人工挑选的。                         | 在界面上**明确展示算法阈值**（如："检测阈值：Spread > 0.05"），表明这是基于规则的客观筛选。 |

### 4.2 技术栈暂定 (Tech Stack)

- **数据处理**: Python (Pandas, NumPy)
- **数据源**: Polymarket Clob API / Historical Data Snapshots
- **前端展示**: Streamlit
- **数据格式**: Static JSON files

## 5. 后续行动 (Next Steps)

1. **Spec 撰写**: 基于本 findings 文档，开始撰写详细的 `SRS (Software Requirements Specification)`。
2. **算法验证**:
   - 编写 Python 脚本计算某市场的 `Price(Yes) + Price(No)`。
   - 观察历史数据中是否存在显著的 `Sum != 1` 的情况，以此确定“套利检测”是否具有实际演示价值。